import paramiko
import winrm

# Create winrm connection.
#sess = winrm.Session('https://192.168.178.19', auth=('kostek', 'kostek'), transport='kerberos')

#on windows target:
#on powershell:
Enable-PSRemoting -SkipNetworkProfileCheck -Force
Set-NetConnectionProfile -NetworkCategory Private

cmd:
winrm qc
winrm e winrm/config/listener
winrm set winrm/config/service @{AllowUnencrypted="true"}
winrm set winrm/config/service/auth @{Basic="true"}
winrm set winrm/config/service/auth @{Kerberos="false"}

#
# sess = winrm.Session('http://192.168.88.128', auth=('kostek', 'kostek'))
# cmds = ["ipconfig /all", "ipconfig /flushdns", "nslookup wp.pl"]
# def run_command(cmdline):
#     print('----- running cmd: {} ------'.format(cmdline))
#     if " " in cmdline:
#         cmd_parts = cmdline.split()
#         cmd = cmd_parts[0]
#         args = cmd_parts[1:]
#     result = sess.run_cmd(cmd, args)
#     print('---- result: {} -----'.format(result))
#
#     print(result.std_err) # .decode("utf-8"):
#     print(result.std_out)
#
# def run_ps(cmd):
#     result = sess.run_ps(cmd)
#     print(result)
#     print(result.std_out)
#     print(result.std_err)
#
# ps_cmds = ["""$computerName=$Host
# echo $computerName
# """, """hostname"""]
#
# for cmd in cmds:
#     run_command(cmd)
#
# #for cmd in ps_cmds:
# #    run_ps(cmd)

# https://stackoverflow.com/questions/18961213/how-to-connect-to-a-remote-windows-machine-to-execute-commands-using-python
# https://stackoverflow.com/questions/28411960/execute-a-command-on-remote-machine-in-python
# https://stackoverflow.com/questions/28411960/execute-a-command-on-remote-machine-in-python/28413657#28413657
# https://python-for-system-administrators.readthedocs.io/en/latest/ssh.html
# https://4sysops.com/archives/enabling-powershell-remoting-fails-due-to-public-network-connection-type/


class SSHConnection:
    def __init__(self, hostname, username, password, timeout=None):
        self._hostname = hostname
        self._username = username
        self._password = password
        self._timeout = None
        if timeout:
            self._timeout = timeout
        self._ssh_connection = self._connect()

    def _connect(self):
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            try:
                if self._timeout:
                    ssh.connect(self._hostname, username=self._username, password=self._password, timeout=self._timeout)
                else:
                    ssh.connect(self._hostname, username=self._username, password=self._password)
                print("Connected to {}".format(self._hostname))

            except TimeoutError as e:
                print("TimeoutError(caught):", e)

        except paramiko.AuthenticationException:
            print("Failed to connect to {} due to wrong username/password".format(self._hostname))
            ssh = None

        except Exception as e:
            print(e.message)
            ssh = None

        return ssh

    def execute_command(self, command):
        try:
            print('running "{}" in linux bash'.format(command))
            command = command.strip()
            std_in, std_out, std_err = self._ssh_connection.exec_command(command)
        except Exception as e:
            print(e.message)

        return std_in, ''.join(std_out.readlines()), ''.join(std_err.readlines())

    def disconnect(self):
        try:
            if self._ssh_connection:
                self._ssh_connection.close()
        except Exception as e:
            print(e.message)
        finally:
            self._ssh_connection = None

    def __del__(self):
        print('disconnecting from host "{}"'.format(self._hostname))
        self._ssh_connection.close()


class WinRMConnection:
    def __init__(self, hostname, username, password, timeout=None):
        self._hostname = hostname
        self._username = username
        self._password = password
        self._timeout = None
        # if timeout:
        #     self._timeout = timeout
        self._connection = self._connect()

    def get_connection(self):
        if self._connection:
            return self._connection
        return None

    def _connect(self):
        try:
            try:
                print('Tryin to connect')
                if self._timeout:
                    connection_session = winrm.Session('http://{}'.format(self._hostname),
                                                       auth=(self._username, self._password),
                                                       read_timeout_sec=self._timeout + 5,
                                                       operation_timeout_sec=self._timeout)
                else:
                    connection_session = winrm.Session('http://{}'.format(self._hostname),
                                                       auth=(self._username, self._password))
                if connection_session:
                    print("Connected to {}".format(self._hostname))
                else:
                    print("Did not connect to {}".format(self._hostname))
                    return
            except TimeoutError as e:
                print("TimeoutError(caught):", e)
                connection_session = None

        except Exception as e:
            print(e.message)
            connection_session = None

        return connection_session

    def execute_command(self, command, method='cmd'):
        try:
            if method == 'cmd':
                response = self._run_cmd(command)
            elif method == 'ps':
                response = self._run_ps(command)
            else:
                return None, None, None

        except Exception as e:
            print(e.message)

        return None, response.std_out, response.std_err

    def _run_cmd(self, cmdline):
        try:
            print('----- running cmd: {} ------'.format(cmdline))
            if " " in cmdline:
                cmd_parts = cmdline.split()
                cmd_core = cmd_parts[0]
                cmd_args = cmd_parts[1:]
                result = self.get_connection().run_cmd(cmd_core, cmd_args)
            else:
                result = self.get_connection().run_cmd(cmdline)
            return result
        except Exception as e:
            print(e)
            return None

    def _run_ps(self, cmdline):
        try:
            print('----- running cmd(ps): {} ------'.format(cmdline))

            result = self.get_connection().run_ps(cmdline)
            return result
        except Exception as e:
            print(e)
            return None

    def disconnect(self):
        try:
            if self._connection:
                self._connection = None
        except Exception as e:
            print(e.message)
        finally:
            self._connection = None

    def __del__(self):
        print('Disconnecting from host "{}"'.format(self._hostname))
        self.disconnect()


class ExecuteRemotely:
    def __init__(self, host, username, password, timeout=None):
        self._host = host
        self._os = DetectOS(self._host).os()
        self._connection = None
        try:
            if 'windows' == self._os:
                print('windows os')
                self._connection = WinRMConnection(self._host, username, password, timeout)
            if 'linux' == self._os:
                print('linux os')
                self._connection = SSHConnection(self._host, username, password, timeout)
        # if not self._connection:
        #     return
        except Exception as e:
            print(e)

    def execute_command(self, command):
        print('connection: ', self._connection)
        if self._connection:

            stdin, stdout, stderr = self._connection.execute_command(command)
            return stdin, stdout, stderr
        else:
            raise MissingParameterException("No connection available")

    def _parse_response(self, stdin, stdout, stderr):
        return stdin, stdout, stderr

    def __del__(self):
        print("Cleaning after class: {} for os: {}".format(self.__class__.__name__, self._os))


import socket


class DetectOS:
    def __init__(self, host_ip=None, timeout=None):
        self._host_ip = host_ip
        # self._timeout = 15
        # if timeout:
        #     self._timeout = timeout
        # print(self._timeout)
        print(self._host_ip)
        if not self._host_ip:
            raise MissingParameterException("host_ip is missing")

    def os(self):
        try:
            try:
                if self._detect_os(port=22):
                    return 'linux'
                # if self._detect_os(port=5985):
                if self._detect_os(port=5985):
                    print('on windows')
                    return 'windows'


            except ConnectionRefusedError as cre:
                print(cre)
                return None

        except Exception as e:
            print(e)
            return None

    def _detect_os(self, port):

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        connection_error = sock.connect((self._host_ip, port))
        # if self._timeout:
        #     sock.settimeout(self._timeout)
        connection_error = sock.connect_ex((self._host_ip, port))
        print(connection_error)
        print('Tryin to connect: connection_error', connection_error)

    # if connection_error:
    #     sock.close()
    #     return not connection_error
    # else:
    #     raise RuntimeWarning(
    #         "Connection to host \"{}\" failed with error: \"{}\"".format(self._host_ip, connection_error))

if __name__ == "__main__":
    try:
        er = ExecuteRemotely('192.168.88.128', 'kostek', 'kostek', timeout=1)
        if er:
            print(er.execute_command("ipconfig /all"))
            print(er.execute_command("ping 192.168.88.1"))
            
        del er

    except Exception as e:
        print(e)
    #
    # try:
    #     ex = ExecuteRemotely('192.168.88.138', 'kostek', 'kostek')
    #     if ex:
    #         comamnds = ["ip address show", "ping 192.168.88.1 -c 4", "man page", "whereis python", "python3 -VV"]
    #         for command in comamnds:
    #             print(ex.execute_command(command))
    #         del ex
    # except Exception as e:
    #     print(e)

